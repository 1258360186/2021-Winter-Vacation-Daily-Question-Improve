# 寒假每日一题

## 第二十二天

### 3205. 最优配餐

#### 题目

栋栋最近开了一家餐饮连锁店，提供外卖服务。

随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。

栋栋的连锁店所在的区域可以看成是一个 $n×n$ 的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。

方格图中的线表示可以行走的道路，相邻两个格点的距离为 $1$。

栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。

![p41.png](https://cdn.acwing.com/media/article/image/2021/01/25/19_077787285e-p41.png)

送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费 $1$ 块钱。

每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。

现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。

#### 输入格式

输入的第一行包含四个整数 $n,m,k,d$，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。

接下来 $m$ 行，每行两个整数 $x_i,y_i$，表示栋栋的一个分店在方格图中的横坐标和纵坐标。

接下来 $k$ 行，每行三个整数 $x_i,y_i,c_i$，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）

接下来 $d$ 行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。

#### 输出格式

输出一个整数，表示最优送餐方式下所需要花费的成本。

#### 数据范围

前 $30%$ 的评测用例满足：$1≤n≤20$。
前 $60%$ 的评测用例满足：$1≤n≤100$。
所有评测用例都满足：$1≤n≤1000,1≤m,k,d≤n^2,1≤x_i,y_i≤n$。
可能有多个客户在同一个格点上。
每个客户的订餐量不超过 $1000$，每个客户所需要的餐都能被送到。

#### 输入样例

```
10 2 3 3
1 1
8 8
1 5 1
2 3 3
6 7 2
1 2
2 2
6 8
```

#### 输出样例

```
29
```

#### AC代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

typedef long long LL;
typedef pair<int,int> PII;

const int N=1010;
int n,m,k,d;
bool g[N][N];// 地图：1：不可走，0：可走
int dist[N][N];//距离
int c[N*N][3];//用户地址和订餐的量
queue<PII> q;

void bfs()
{
    int dx[]={-1,0,1,0},dy[]={0,1,0,-1};
    while(q.size())
    {
        PII t=q.front();//取队头
        q.pop();//出队
        for(int i=0;i<4;i++)//向四个方向进行遍历
        {
            int x=dx[i]+t.first,y=dy[i]+t.second;
            if (x < 1 || x > n || y < 1 || y > n || g[x][y]) continue;//如果能不能走过去
            if(dist[x][y]>dist[t.first][t.second]+1)//如果距离变小
            {
                dist[x][y]=dist[t.first][t.second]+1;//更新距离
                q.push({x,y});//并且入队
            }
        }
    }
}

int main()
{
    cin >> n >> m >> k >> d;
    memset(dist,0x3f,sizeof(dist));//初始化dist,各个元素为int最大值
    while(m--)
    {
        int x,y;
        scanf("%d%d", &x, &y);
        q.push({x,y});//分店入队列
        dist[x][y]=0;//分店的送餐距离为 0
    }
    for(int i=0;i<k;i++)//保存客户信息
    {
        scanf("%d%d%d%D", &c[i][0], &c[i][1], &c[i][2]);
    }
    while(d--)
    {
        int x,y;
        scanf("%d%d", &x, &y);
        g[x][y]=true;
    }
    bfs();
    LL res = 0;
    for (int i = 0; i < k; i ++ )//求出各个客户的成本
        res += dist[c[i][0]][c[i][1]] * c[i][2];
    cout << res << endl;
    return 0;
}

```

#### 解题思路

> **最短路($BFS$)**

>1.求出分店到各个点的最短距离
>
>2.根据最短距离求出最少成本
>
>3.输出成本

