# 寒假每日一题

## 第十三天

### 312. 乌龟棋

#### 题目

小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

乌龟棋的棋盘只有一行，该行有 N 个格子，每个格子上一个分数（非负整数）。

棋盘第 1 格是唯一的起点，第 N 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中共有 M 张爬行卡片，分成 4 种不同的类型（M 张卡片中不一定包含所有 4 种类型的卡片），每种类型的卡片上分别标有1、2、3、4 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。

游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。

游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。

玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。

很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。

现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？

#### 输入格式

输入文件的每行中两个数之间用一个空格隔开。

第 1 行 2 个正整数 N 和 M，分别表示棋盘格子数和爬行卡片数。

第 2 行 N 个非负整数，$a_1,a_2,……,a_N$，其中 $a_i$ 表示棋盘第 i 个格子上的分数。

第 3 行 M 个整数，$b_1,b_2,……,b_M$，表示 M 张爬行卡片上的数字。

输入数据保证到达终点时刚好用光 M 张爬行卡片。

#### 输出格式

输出只有 1 行，包含 1 个整数，表示小明最多能得到的分数。

#### 数据范围

$1≤N≤350$,
$1≤M≤120$,
$0≤a_i≤100$,
$1≤b_i≤4$,
每种爬行卡片的张数不会超过40。

#### 输入样例

```
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1
```

#### 输出样例

```
73
```

#### AC代码

```c++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

int n,m;
int a[360],b[5],c[40][40][40][40];

int main()
{
    cin >> n >>m;
    for(int i=0;i<n;i++) cin >> a[i];
    for(int i=0;i<m;i++) 
    {
        int t;
        cin >> t;
        b[t]++;
    }
    for(int A=0;A<=b[1];A++)
        for(int B=0;B<=b[2];B++)
            for(int C=0;C<=b[3];C++)
                for(int D=0;D<=b[4];D++)
                {
                    int t=a[A+2*B+3*C+4*D];
                    int &temp=c[A][B][C][D];
                    temp = t;
                    if(A) temp = max(temp,c[A-1][B][C][D]+t);
                    if(B) temp = max(temp,c[A][B-1][C][D]+t);
                    if(C) temp = max(temp,c[A][B][C-1][D]+t);
                    if(D) temp = max(temp,c[A][B][C][D-1]+t);
                }
    cout << c[b[1]][b[2]][b[3]][b[4]] << endl;
    return 0;
}
```

#### 解题思路

> **线性DP**

>状态表示：$f[b_1,b_2,b_3,b_4]$ 表示所有第 $i$ 种卡片使用了 $b_i$ 张的走法的最大分值。
>
>状态计算：将 $f[b1,b2,b3,b4]$ 表示的所有走法按最后一步选择哪张卡片分成四类：第 $i$ 类为最后一步选择第 $i$ 种卡片。比如 $i=2$，则这一类的最大分值是 $f[b_1,b_2−1,b_3,b_4]+score[b_1+2b_2+3b_3+4b_4]$。

