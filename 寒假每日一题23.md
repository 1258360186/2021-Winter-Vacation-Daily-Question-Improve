# 寒假每日一题

## 第二十三天

### 3215. 网络延时

#### 题目

给定一个公司的网络，由 $n$ 台交换机和 $m$ 台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。

交换机按层级设置，编号为 $1$ 的交换机为根交换机，层级为 $1$。

其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加 $1$。

所有的终端电脑都直接连接到交换机上。

当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。

请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。

#### 输入格式

输入的第一行包含两个整数 $n,m$，分别表示交换机的台数和终端电脑的台数。

第二行包含 $n−1$ 个整数，分别表示第 $2、3、……、n$ 台交换机所连接的比自己上一层的交换机的编号。第 $i$ 台交换机所连接的上一层的交换机编号一定比自己的编号小。

第三行包含 $m$ 个整数，分别表示第 $1、2、……、m$ 台终端电脑所连接的交换机的编号。

#### 输出格式

输出一个整数，表示消息传递最多需要的步数。

#### 数据范围

前 $30\%$ 的评测用例满足：$n≤5,m≤5$。
前 $50\%$ 的评测用例满足：$n≤20,m≤20$。
前 $70\%$ 的评测用例满足：$n≤100,m≤100$。
所有评测用例都满足：$1≤n≤10000，1≤m≤10000$。

#### 输入样例1：

```
4 2
1 1 3
2 1
```

#### 输出样例1：

```
4
```

#### 样例1解释

样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：

![network1.png](https://cdn.acwing.com/media/article/image/2021/01/27/19_76a37e7060-network1.png)

其中电脑 11 与交换机 44 之间的消息传递花费的时间最长，为 44 个单位时间。

#### 输入样例2：

```
4 4
1 2 2
3 4 4 4
```

#### 输出样例2：

```
4
```

#### 样例2解释

样例的网络连接模式如下：

![network2.png](https://cdn.acwing.com/media/article/image/2021/01/27/19_9aa4dfda60-network2.png)

其中电脑 11 与电脑 44 之间的消息传递花费的时间最长，为 44 个单位时间。

#### AC代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int n,m;
int h[20010],e[20010],ne[20010],idx;
int res;

void add(int x,int y)
{
    e[idx]=y;ne[idx]=h[x];h[x]=idx++;
}

int dfs(int u)
{
    int d1 = 0, d2 = 0;//d1记录u到最远叶节点的距离，d2记录u到次远叶节点的距离
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        int d = dfs(j);//子节点j到最远叶节点的距离
        if (d >= d1) d2 = d1, d1 = d;
        else if (d > d2) d2 = d;
    }
    res = max(res, d1 + d2);//最后的答案就是u所能到的最远叶节点距离和次远叶节点距离之和
    return d1 + 1;//返回u通过j能到的最远叶节点的距离和次远叶节点距离之和
}

int main()
{
    cin >> n >> m;
    memset(h,-1,sizeof h);
    for (int i = 2; i <= n+m; i ++ )//电脑其实和交换机等价，所以电脑的标号从n继续往后标记即可
    {
        int p;
        cin >> p;
        add(p, i);//因为是自根向下DP，所以建一条边即可。
    }
    dfs(1);
    cout << res << endl;
    return 0;
}
```

#### 解题思路

> **树的最长路径**

>

