# 寒假每日一题

## 第九天

### 499. 聪明的质监员

#### 题目

小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 n 个矿石，从 1 到 n 逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$。

检验矿产的流程是： 

1、给定 m 个区间[$L_i$，$R_i$]； 
2、选出一个参数 W； 
3、对于一个区间[$L_i$，$R_i$]，计算矿石在这个区间上的检验值 $Y_i$ ： 

![QQ截图20190314005531.png](https://www.acwing.com/media/article/image/2019/03/14/19_d878de0845-QQ%E6%88%AA%E5%9B%BE20190314005531.png)

这批矿产的检验结果 Y 为各个区间的检验值之和。

即：Y = $Y_1+Y_2+…+Y_m$

若这批矿产的检验结果与所给标准值 S 相差太多，就需要再去检验另一批矿产。

小 T 不想费时间去检验另一批矿产，所以他想通过调整参数 W 的值，让检验结果尽可能的靠近标准值 S，即使得 S-Y 的绝对值最小。

请你帮忙求出这个最小值。

#### 输入格式

第一行包含三个整数 n，m，S，分别表示矿石的个数、区间的个数和标准值。 

接下来的 n 行，每行 2 个整数，中间用空格隔开，第 i+1 行表示 i 号矿石的重量 $w_i$ 和价值 $v_i$ 。 

接下来的 m 行，表示区间，每行 2 个整数，中间用空格隔开，第 i+n+1 行表示区间[$L_i$, $R_i$]的两个端点 $L_i$ 和 $R_i$。

注意：不同区间可能重合或相互重叠。

#### 输出格式

输出一个整数，表示所求的最小值。

#### 数据范围

$1≤n,m≤200000$,
$0<w_i,v_i≤10^6$,
$0<S≤10^{12}$,
$1≤L_i≤R_i≤n$

#### 输入样例

```
5 3 15 
1 5 
2 5 
3 5 
4 5 
5 5 
1 5 
2 4 
3 3 
```

#### 输出样例

```
10
```

#### AC代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;
int n,m;
LL s;
int w[200010],v[200010];
LL sv[200010];
int num[200010];
int l[200010],r[200010];

LL get(int x)
{
    for(int i=1;i<=n;i++)
        if(w[i]>=x)
        {
            sv[i]=sv[i-1]+v[i];
            num[i]=num[i-1]+1;
        }
        else
        {
            sv[i]=sv[i-1];
            num[i]=num[i-1];
        }
    LL res=0;
    for(int i=0;i<m;i++) res+=(num[r[i]]-num[l[i]-1])*(sv[r[i]]-sv[l[i]-1]);
    return res;
}

int main()
{
    cin >> n >> m >> s;
    for(int i=1;i<=n;i++) cin >> w[i] >> v[i];
    for(int i=0;i<m;i++) cin >> l[i] >> r[i];
    int l=0,r=1e6+1;
    while(l<r)
    {
        int mid = l+r+1>>1;
        if(get(mid)>=s) l=mid;
        else r=mid-1;
    }
    LL res =min(abs(get(l)-s),abs(s-get(l+1)));
    cout << res << endl;
    return 0;
}
```

#### 解题思路

> **二分+前缀和**

>观察每个区间的值 $Y_i=(∑_j1)∗(∑_jv_j),j∈[L_i,R_i]且w_j≥W$。
>
>当 $W$ 增大时，区间 $[L_i,R_i]$ 中满足要求的 $(w_i,v_i)$ 会减少，同时所有 $v_i≥0$，因此 $Y_i$ 的值也会减少。
>
>由于 $Y=∑_iY_i$，所以 $Y$ 随 $W$ 单调递减。
>
>因此我们可以二分出距离 $S$ 最近的值。
>
>剩下的问题是当 $W$ 确定之后，我们如何快速求出每个 $Y_i$。
>这里可以预处理出所有满足 $w_i≥W$ 的元素的前缀和，之后可以 $O(1)$ 时间求出每个区间中所有 $v_i$ 的和，以及满足要求的元素个数。
>[转载链接](https://www.acwing.com/solution/content/3044/)

