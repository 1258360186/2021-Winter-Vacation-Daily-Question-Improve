# 寒假每日一题

## 第二十四天

### 3250. 通信网络

#### 题目

某国的军队由 $N$ 个部门组成，为了提高安全性，部门之间建立了 $M$ 条通路，每条通路只能单向传递信息，即一条从部门 $a$ 到部门 $b$ 的通路只能由 $a$ 向 $b$ 传递信息。

信息可以通过中转的方式进行传递，即如果 $a$ 能将信息传递到 $b$，$b$ 又能将信息传递到 $c$，则 $a$ 能将信息传递到 $c$。

一条信息可能通过多次中转最终到达目的地。

由于保密工作做得很好，并不是所有部门之间都互相知道彼此的存在。

只有当两个部门之间可以直接或间接传递信息时，他们才彼此知道对方的存在。

部门之间不会把自己知道哪些部门告诉其他部门。

![p1.png](https://cdn.acwing.com/media/article/image/2021/02/06/19_93d693ad68-p1.png)

上图中给了一个 $4$ 个部门的例子，图中的单向边表示通路。

部门 $1$ 可以将消息发送给所有部门，部门 $4$ 可以接收所有部门的消息，所以部门 $1$ 和部门 $4$ 知道所有其他部门的存在。

部门 $2$ 和部门 $3$ 之间没有任何方式可以发送消息，所以部门 $2$ 和部门 $3$ 互相不知道彼此的存在。

现在请问，有多少个部门知道所有 $N$ 个部门的存在。

或者说，有多少个部门所知道的部门数量（包括自己）正好是 $N$。

#### 输入格式

输入的第一行包含两个整数 $N,M$，分别表示部门的数量和单向通路的数量。所有部门从 $1$ 到 $N$ 标号。

接下来 $M$ 行，每行两个整数 $a,b$，表示部门 $a$ 到部门 $b$ 有一条单向通路。

#### 输出格式

输出一行，包含一个整数，表示答案。

#### 数据范围

对于 $30\%$ 的评测用例，$1≤N≤10，1≤M≤20$；
对于 $60\%$ 的评测用例，$1≤N≤100，1≤M≤1000$；
对于 $100\%$ 的评测用例，$1≤N≤1000，1≤M≤10000$。

#### 输入样例：

```
4 4
1 2
1 3
2 4
3 4
```

#### 输出样例：

```
2
```

#### 样例解释

部门 $1$ 和部门 $4$ 知道所有其他部门的存在。

#### AC代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int n,m;
int h1[1010],h2[1010],ne[20010],e[20010],idx;
bool st1[1010],st2[1010];

void add(int h[],int x,int y)
{
    e[idx]=y;ne[idx]=h[x];h[x]=idx++;
}

void dfs(int u, int h[], bool st[])
{
    st[u]=true;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j, h, st);
    }
}

int main()
{
    cin >> n >> m;
    memset(h1,-1,sizeof h1);
    memset(h2,-1,sizeof h2);
    while(m--)
    {
        int a,b;
        cin >> a >> b;
        add(h1,a,b);add(h2,b,a);
    }
    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        memset(st1, 0, sizeof st1);
        memset(st2, 0, sizeof st2);
        dfs(i, h1, st1);
        dfs(i, h2, st2);
        int s = 0;
        for (int j = 1; j <= n; j ++ )
            if (st1[j] || st2[j])
                s ++ ;
        if (s == n) res ++ ;
    }
    cout << res << endl;
    return 0;
}
```

#### 解题思路

> **邻接表**

>

